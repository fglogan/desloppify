"""Shared command factories for detect subcommands.

Commands that are structurally identical across languages (same detect call +
display_entries pattern, differing only in parameters) are generated here.
Language-specific commands with unique display logic stay in their own modules.
"""

from __future__ import annotations

import inspect
import json
from collections.abc import Callable
from pathlib import Path
from typing import TYPE_CHECKING, Any

from desloppify.engine.detectors import complexity as complexity_detector
from desloppify.engine.detectors import large as large_detector
from desloppify.engine.detectors import naming as naming_detector
from desloppify.engine.detectors import single_use as single_use_detector
from desloppify.utils import colorize, display_entries, print_table, rel

if TYPE_CHECKING:
    import argparse

    from desloppify.engine.detectors.base import ComplexitySignal


def _bind_callsite_module(fn: Callable[..., Any]) -> Callable[..., Any]:
    """Attribute generated command functions to the language commands module."""
    frame = inspect.currentframe()
    caller = frame.f_back.f_back if frame and frame.f_back else None
    module_name = caller.f_globals.get("__name__") if caller else None
    if isinstance(module_name, str):
        fn.__module__ = module_name
    del frame
    return fn


def make_cmd_large(
    file_finder: Callable[..., Any], default_threshold: int
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect large files."""

    def cmd_large(args: argparse.Namespace) -> None:
        threshold = getattr(args, "threshold", default_threshold)
        entries, _ = large_detector.detect_large_files(
            Path(args.path),
            file_finder=file_finder,
            threshold=threshold,
        )
        display_entries(
            args,
            entries,
            label=f"Large files (>{threshold} LOC)",
            empty_msg=f"No files over {threshold} lines.",
            columns=["File", "LOC"],
            widths=[70, 6],
            row_fn=lambda e: [rel(e["file"]), str(e["loc"])],
        )

    return _bind_callsite_module(cmd_large)


def make_cmd_complexity(
    file_finder: Callable[..., Any],
    signals: list[ComplexitySignal],
    default_threshold: int = 15,
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect complexity signals."""

    def cmd_complexity(args: argparse.Namespace) -> None:
        entries, _ = complexity_detector.detect_complexity(
            Path(args.path),
            signals=signals,
            file_finder=file_finder,
            threshold=default_threshold,
        )
        display_entries(
            args,
            entries,
            label="Complexity signals",
            empty_msg="No significant complexity signals found.",
            columns=["File", "LOC", "Score", "Signals"],
            widths=[55, 5, 6, 45],
            row_fn=lambda e: [
                rel(e["file"]),
                str(e["loc"]),
                str(e["score"]),
                ", ".join(e["signals"][:4]),
            ],
        )

    return _bind_callsite_module(cmd_complexity)


def make_cmd_single_use(
    build_dep_graph: Callable[..., Any], barrel_names: set[str]
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect single-use abstractions."""

    def cmd_single_use(args: argparse.Namespace) -> None:
        graph = build_dep_graph(Path(args.path))
        entries, _ = single_use_detector.detect_single_use_abstractions(
            Path(args.path), graph, barrel_names=barrel_names
        )
        display_entries(
            args,
            entries,
            label="Single-use abstractions",
            empty_msg="No single-use abstractions found.",
            columns=["File", "LOC", "Only Imported By"],
            widths=[45, 5, 60],
            row_fn=lambda e: [rel(e["file"]), str(e["loc"]), e["sole_importer"]],
        )

    return _bind_callsite_module(cmd_single_use)


def make_cmd_passthrough(
    detect_fn: Callable[..., Any],
    noun: str,
    name_key: str,
    total_key: str,
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect passthrough components/functions."""

    def cmd_passthrough(args: argparse.Namespace) -> None:
        entries = detect_fn(Path(args.path))
        display_entries(
            args,
            entries,
            label=f"Passthrough {noun}s",
            empty_msg=f"No passthrough {noun}s found.",
            columns=["Name", "File", "PT/Total", "Ratio", "Tier", "Line"],
            widths=[30, 55, 10, 7, 5, 6],
            row_fn=lambda e: [
                e[name_key],
                rel(e["file"]),
                f"{e['passthrough']}/{e[total_key]}",
                f"{e['ratio']:.0%}",
                f"T{e['tier']}",
                str(e["line"]),
            ],
        )

    return _bind_callsite_module(cmd_passthrough)


def make_cmd_naming(
    file_finder: Callable[..., Any],
    skip_names: set[str],
    skip_dirs: set[str] | None = None,
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect naming inconsistencies."""

    def cmd_naming(args: argparse.Namespace) -> None:
        kwargs = dict(file_finder=file_finder, skip_names=skip_names)
        if skip_dirs:
            kwargs["skip_dirs"] = skip_dirs
        entries, _ = naming_detector.detect_naming_inconsistencies(
            Path(args.path), **kwargs
        )
        display_entries(
            args,
            entries,
            label="Naming inconsistencies",
            empty_msg="\nNo naming inconsistencies found.",
            columns=["Directory", "Majority", "Minority", "Outliers"],
            widths=[45, 20, 20, 40],
            row_fn=lambda e: [
                e["directory"],
                f"{e['majority']} ({e['majority_count']})",
                f"{e['minority']} ({e['minority_count']})",
                ", ".join(e["outliers"][:5])
                + (f" (+{len(e['outliers']) - 5})" if len(e["outliers"]) > 5 else ""),
            ],
        )

    return _bind_callsite_module(cmd_naming)


def make_cmd_facade(
    build_dep_graph_fn: Callable[..., Any],
    detect_facades_fn: Callable[..., tuple[list[dict], int]],
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect re-export facades."""

    def cmd_facade(args: argparse.Namespace) -> None:
        graph = build_dep_graph_fn(Path(args.path))
        entries, _ = detect_facades_fn(graph)
        if getattr(args, "json", False):
            print(
                json.dumps(
                    {
                        "count": len(entries),
                        "entries": [{**e, "file": rel(e["file"])} for e in entries],
                    },
                    indent=2,
                )
            )
            return
        if not entries:
            print(colorize("\nNo re-export facades found.", "green"))
            return
        file_facades = [e for e in entries if e["kind"] == "file"]
        dir_facades = [e for e in entries if e["kind"] == "directory"]
        if file_facades:
            print(colorize(f"\nRe-export facade files: {len(file_facades)}\n", "bold"))
            rows = [
                [
                    rel(e["file"]),
                    str(e["loc"]),
                    str(e["importers"]),
                    ", ".join(e["imports_from"][:3]),
                ]
                for e in file_facades
            ]
            print_table(
                ["File", "LOC", "Importers", "Re-exports From"], rows, [50, 5, 9, 40]
            )
        if dir_facades:
            print(colorize(f"\nFacade directories: {len(dir_facades)}\n", "bold"))
            rows = [
                [rel(e["file"]), str(e.get("file_count", "?")), str(e["importers"])]
                for e in dir_facades
            ]
            print_table(["Directory", "Files", "Importers"], rows, [50, 6, 9])

    return _bind_callsite_module(cmd_facade)


def make_cmd_smells(
    detect_smells_fn: Callable[..., Any],
) -> Callable[[argparse.Namespace], None]:
    """Factory: detect code smells."""

    def cmd_smells(args: argparse.Namespace) -> None:
        entries, _ = detect_smells_fn(Path(args.path))
        if getattr(args, "json", False):
            print(json.dumps({"entries": entries}, indent=2))
            return
        if not entries:
            print(colorize("No code smells detected.", "green"))
            return
        total = sum(e["count"] for e in entries)
        print(
            colorize(
                f"\nCode smells: {total} instances across {len(entries)} patterns\n",
                "bold",
            )
        )
        rows = []
        for e in entries[: getattr(args, "top", 20)]:
            sev_color = {"high": "red", "medium": "yellow", "low": "dim"}.get(
                e["severity"], "dim"
            )
            rows.append(
                [
                    colorize(e["severity"].upper(), sev_color),
                    e["label"],
                    str(e["count"]),
                    str(e["files"]),
                ]
            )
        print_table(["Sev", "Pattern", "Count", "Files"], rows, [8, 40, 6, 6])
        high = [e for e in entries if e["severity"] == "high"]
        for e in high:
            print(colorize(f"\n  {e['label']} ({e['count']} instances):", "red"))
            for m in e["matches"][:10]:
                print(f"    {rel(m['file'])}:{m['line']}  {m['content'][:60]}")

    return _bind_callsite_module(cmd_smells)


def build_standard_detect_registry(
    *,
    cmd_deps: Callable[[argparse.Namespace], None],
    cmd_cycles: Callable[[argparse.Namespace], None],
    cmd_orphaned: Callable[[argparse.Namespace], None],
    cmd_dupes: Callable[[argparse.Namespace], None],
    cmd_large: Callable[[argparse.Namespace], None],
    cmd_complexity: Callable[[argparse.Namespace], None],
) -> dict[str, Callable[[argparse.Namespace], None]]:
    """Build the shared detect command mapping used by language plugins."""
    return {
        "deps": cmd_deps,
        "cycles": cmd_cycles,
        "orphaned": cmd_orphaned,
        "dupes": cmd_dupes,
        "large": cmd_large,
        "complexity": cmd_complexity,
    }


def make_get_detect_commands(
    *,
    cmd_deps: Callable[[argparse.Namespace], None],
    cmd_cycles: Callable[[argparse.Namespace], None],
    cmd_orphaned: Callable[[argparse.Namespace], None],
    cmd_dupes: Callable[[argparse.Namespace], None],
    cmd_large: Callable[[argparse.Namespace], None],
    cmd_complexity: Callable[[argparse.Namespace], None],
) -> Callable[[], dict[str, Callable[[argparse.Namespace], None]]]:
    """Build a shared get_detect_commands closure for language modules."""

    def get_detect_commands() -> dict[str, Callable[[argparse.Namespace], None]]:
        return build_standard_detect_registry(
            cmd_deps=cmd_deps,
            cmd_cycles=cmd_cycles,
            cmd_orphaned=cmd_orphaned,
            cmd_dupes=cmd_dupes,
            cmd_large=cmd_large,
            cmd_complexity=cmd_complexity,
        )

    return get_detect_commands
